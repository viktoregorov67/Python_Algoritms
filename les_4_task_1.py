# Проанализировать скорость и сложность одного любого алгоритма из разработанных
# в рамках домашнего задания первых трех уроков.
# Анализируем задачу 3 из домашнего задания урока 2:
# Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.

import timeit
import cProfile

# Решение с помощью рекурсии
def reverse(num, b = 0):
    if num // 10 == 0:
        return b * 10 + num
    else:
        return reverse(num // 10, (10 * b) + (num % 10))

# С помощью цикла
def cicle_(n):
    m = 0
    while n > 0:
        m = m * 10 + n % 10
        n = n // 10
    return m
# Через списки (более универсальный, подходит и для текста)
def list_(a):
    b = list(str(a))
    reverse = "".join(b[::-1])
    return reverse

# Оценка времени выполнения

# s = """
# def reverse(num, b = 0):
#     if num // 10 == 0:
#         return b * 10 + num
#     else:
#         return reverse(num // 10, (10 * b) + (num % 10))
#
# reverse(123456789012345678901234567890)
# """

# s = """
# def cicle_(n):
#     m = 0
#     while n > 0:
#         m = m * 10 + n % 10
#         n = n // 10
#     return m
#
# cicle_(123456789012345678901234567890)
# """

# s = """
# def list_(a):
#     b = list(str(a))
#     reverse = "".join(b[::-1])
#     return reverse
#
# list_(123456789012345678901234567890)
# """

# print(timeit.timeit(s, number=100))
# 0.019234299999999982 reverse(12345678901234567890123456789012345678901234567890)
# 0.010684200000000005 reverse(1234567890123456789012345678901234567890)
# 0.007608199999999982 reverse(123456789012345678901234567890)

# 0.008368799999999954 cicle_(12345678901234567890123456789012345678901234567890)
# 0.006221500000000005 cicle_(1234567890123456789012345678901234567890)
# 0.004442800000000011 cicle_(123456789012345678901234567890)

# 0.001597499999999974 list_(12345678901234567890123456789012345678901234567890)
# 0.0011598000000000025 list_(1234567890123456789012345678901234567890)
# 0.0010058000000000011 list_(123456789012345678901234567890)


#cProfile.run('reverse(123456789012345678901234567890)')
#reverse(1234567890)
# 10/1    0.000    0.000    0.000    0.000 les_4_task_1.py:10(reverse)
# reverse(12345678901234567890)
# 20/1    0.000    0.000    0.000    0.000 les_4_task_1.py:10(reverse)
# reverse(123456789012345678901234567890)
# 30/1    0.000    0.000    0.000    0.000 les_4_task_1.py:10(reverse)

# cProfile.run('cicle_(12345678901234567890123456789012345678901234567890)')
# cicle_(12345678901234567890123456789012345678901234567890)
#  1    0.000    0.000    0.000    0.000 les_4_task_1.py:17(cicle_)

# cProfile.run('list_(12345678901234567890123456789012345678901234567890)')
# 1    0.000    0.000    0.000    0.000 les_4_task_1.py:24(list_)

# Вывод: Согласно полученным результатам метод списков работает быстрее всех их предложенных. У рекурсивной функции
# по результатам самое большое время обработки.
# Предварительная оценка сложности алгоритмов О(n)